<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Voice Transcription</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
        }
        h1 {
            margin-bottom: 20px;
        }
        button {
            padding: 12px 20px;
            margin: 10px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.2s;
        }
        button.record {
            background: #007bff;
            color: white;
        }
        button.record:hover {
            background: #0056b3;
        }
        #transcript {
            margin-top: 20px;
            font-size: 18px;
            color: #333;
            padding: 15px;
            background: #fff;
            border-radius: 10px;
            width: 60%;
            text-align: center;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>
<h1>🎤 Voice Assistant</h1>
<button id="recordBtn" class="record">Start Speaking</button>
<div id="transcript">Your transcript will appear here...</div>

<script>
    const recordBtn = document.getElementById("recordBtn");
    const transcriptDiv = document.getElementById("transcript");

    let mediaRecorder;
    let audioChunks = [];
    let silenceTimer;
    let audioContext, analyser, source, dataArray;

    async function startRecording() {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        mediaRecorder = new MediaRecorder(stream, { mimeType: "audio/webm" });

        audioChunks = [];
        mediaRecorder.ondataavailable = event => {
            if (event.data.size > 0) audioChunks.push(event.data);
        };

        mediaRecorder.onstop = async () => {
            const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
            const formData = new FormData();
            formData.append("audio", audioBlob, "recording.webm");

            try {
                const response = await fetch("/transcribe", {
                    method: "POST",
                    body: formData
                });
                const data = await response.json();
                transcriptDiv.textContent = data.transcript || "No speech detected.";
            } catch (err) {
                transcriptDiv.textContent = "⚠️ Error transcribing audio.";
                console.error(err);
            }
        };

        mediaRecorder.start();
        recordBtn.textContent = "Listening... 🎙️";

        // 🎯 Setup silence detection
        audioContext = new AudioContext();
        source = audioContext.createMediaStreamSource(stream);
        analyser = audioContext.createAnalyser();
        dataArray = new Uint8Array(analyser.fftSize);
        source.connect(analyser);

        detectSilence(() => {
            stopRecording();
        }, 2000, 0.02); // stop if silence > 2s
    }

    function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
            mediaRecorder.stop();
            recordBtn.textContent = "Start Speaking";
            if (audioContext) audioContext.close();
        }
    }

    function detectSilence(onSilence, timeout = 2000, threshold = 0.02) {
        let silenceStart = performance.now();

        function check() {
            analyser.getByteFrequencyData(dataArray);
            let average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

            if (average < threshold * 256) {
                if (performance.now() - silenceStart > timeout) {
                    onSilence();
                    return;
                }
            } else {
                silenceStart = performance.now();
            }
            requestAnimationFrame(check);
        }
        check();
    }

    recordBtn.addEventListener("click", () => {
        if (!mediaRecorder || mediaRecorder.state === "inactive") {
            startRecording();
        } else {
            stopRecording();
        }
    });
</script>
</body>
</html>
